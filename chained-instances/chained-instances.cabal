cabal-version: 3.0

name: chained-instances
version: 0.0.1
synopsis: Chaining dependencies through re-export.

description: Consider a signature A with a type AT and a constraint
  say Show AT.  The Derived module imports a module with signature B
  (which has BT and the constraint show BT) and produces an instance
  of A by just type aliasing BT as AT. Therefore when we mixin a
  instance of B say Concrete with Derived, we should be getting an
  instance of A. However, as this example demonstrates, it seems while
  compiling the Show constraint is not being met.

build-type:    Simple

common defaults
  default-language: Haskell2010
  ghc-options: -Wall
  build-depends: base                    >= 4.11 &&  < 4.14

library derived
  import: defaults
  hs-source-dirs: derived
  signatures: B
  exposed-modules: Derived

library client
  import: defaults
  hs-source-dirs: client
  signatures: A
  exposed-modules: Client

library concrete
  import: defaults
  hs-source-dirs: concrete
  exposed-modules: Concrete


library junction
  import: defaults
  visibility: public
  build-depends: client
               , derived
  reexported-modules: Junction.Client
  mixins: derived (Derived as Junction.Derived) requires (B as Concrete)
        , client (Client as Junction.Client) requires (A as Junction.Derived)
